<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <title>GCSG01'blogs</title>
    <meta charset="UTF-8">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&display=swap'); /* 导入卡通字体 */
        body {
            background-color: #000; /* 设置背景颜色为黑色 */
            color: #ccc; /* 设置文字颜色为浅灰色 */
            background-image: url('https://cdn.luogu.com.cn/upload/image_hosting/642zl9yy.png');
            background-size: cover; /* 使背景图片自动缩放以覆盖整个元素 */
            background-repeat: no-repeat; /* 防止图片重复 */
            background-attachment: fixed; /* 使背景图片固定，不随滚动条滚动 */
            position: relative; /* 设置相对定位 */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); /* 添加文字阴影 */
            display: flex;
            flex-direction: column; /* 使内容垂直排列 */
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* 确保页面高度覆盖整个视口 */
            margin: 0;
        }
        body::before {
            content: ''; /* 伪元素内容为空 */
            position: absolute; /* 绝对定位 */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* 半透明的黑色背景，更深的黑色 */
            z-index: -1; /* 将伪元素置于背景图片之下 */
        }
        h1, h2 {
            font-family: 'Comic Neue', cursive; /* 使用卡通字体 */
            text-align: center; /* 文字居中 */
        }
        .content-box {
            background-color: rgba(0, 0, 0, 0.5); /* 半透明的黑色背景 */
            border-radius: 10px; /* 圆角边框 */
            padding: 20px; /* 内边距 */
            margin: 10px; /* 外边距 */
            width: 80%; /* 宽度 */
            max-width: 800px; /* 最大宽度 */
            text-align: justify; /* 文字两端对齐 */
        }
        .copy-button {
            background-color: #4CAF50; /* 绿色背景 */
            border: none; /* 无边框 */
            color: white; /* 白色文字 */
            padding: 10px 20px; /* 内边距 */
            text-align: center; /* 文字居中 */
            text-decoration: none; /* 无下划线 */
            display: inline-block; /* 行内块元素 */
            font-size: 16px; /* 字体大小 */
            margin: 4px 2px; /* 外边距 */
            cursor: pointer; /* 鼠标指针样式 */
            border-radius: 5px; /* 圆角边框 */
        }
        .container {
            display: flex;
            flex-direction: column; /* 使内容垂直排列 */
            align-items: center; /* 居中对齐 */
            width: 80%;
            max-width: 800px;
        }
        .floating-window {
            position: fixed; /* 固定定位 */
            top: 150px; /* 距离顶部10px */
            right: 350px; /* 距离右侧10px */
            background-color: rgba(0, 0, 0, 0.7); /* 半透明的黑色背景 */
            border-radius: 5px; /* 圆角边框 */
            padding: 10px; /* 内边距 */
            z-index: 1000; /* 确保在最上层 */
        }
        .floating-window a {
            color: #ccc; /* 链接颜色 */
            text-decoration: none; /* 无下划线 */
            margin-right: 10px; /* 链接之间的间距 */
        }
        .right-links {
            position: fixed; /* 固定定位 */
            top: 200px; /* 距离顶部50px */
            right: 440px; /* 距离右侧10px */
            background-color: rgba(0, 0, 0, 0.7); /* 半透明的黑色背景 */
            border-radius: 5px; /* 圆角边框 */
            padding: 10px; /* 内边距 */
            z-index: 1000; /* 确保在最上层 */
        }
        .right-links a {
            color: #ccc; /* 链接颜色 */
            text-decoration: none; /* 无下划线 */
            display: block; /* 每个链接占一行 */
            margin-bottom: 5px; /* 链接之间的间距 */
        }
    </style>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <div class="floating-window">
        <a href="#题目描述">题目描述</a>
        <a href="#思路">思路</a>
        <a href="#Code">代码</a>
    </div>

    <div class="right-links">
        <a href="https://gcsg01.github.io/Blogs/list.html">博客列表</a>
        <a href="https://gcsg01.github.io/">主页</a>
    </div>

    <div class="container">
        <div class="content-box">
            <h2 id="题目描述">题目描述</h2>
            <p>在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。</p>
            <p>每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 \( n-1 \) 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。</p>
            <p>因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 \( 1 \) ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。</p>
        </div>

        <div class="content-box">
            <h2 id="思路">思路</h2>
            <p>很明显的一道贪心题，每次选择最小的两堆进行合并操作。看到很多大佬都在用堆，我在这里提供一种不用堆的方法：STL快排</p>
            <p>我们在输入后首先 \( \text{sort} \) 一遍，然后循环 \( n-1 \) 次，每次都合并最小的两堆 \( a_i \) 与 \( a_{i+1} \) ，把他们并到 \( a_{i+1} \) ，然后再 \( \text{sort} \) 一次。但这样会 \( \text{TLE} \) 。</p>
            <p>我们考虑优化，第 \( i \) 轮时，处理了 \( a_i \) 与 \( a_{i+1} \) ，\( a_{i} \) 之前的有没有序已经对结果无影响，因此，只需对 \( a_{i+1} \) 到 \( a_n \) 进行排序就行。</p>
        </div>

        <div class="content-box">
            <h2 id="Code">Code</h2>
            <pre><code id="code-to-copy">
#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[60000];
int main()
{
    int n;
    cin>>n;
    for(int i=1;i&lt;=n;i++)cin>>a[i];
    sort(a+1,a+n+1);
    int sum=0;
    for(int i=1;i&lt;n;i++)
    {
        a[i+1]+=a[i];
        sum+=a[i+1];//统计消耗的体力
        a[i]=0;
        sort(a+i+1,a+n+1);//对i+1~n堆进行排序
    }
    cout&lt;&lt;sum;
    return 0;
}
            </code></pre>
            <button class="copy-button" onclick="copyCode()">复制代码</button>
        </div>
    </div>

    <script>
        function copyCode() {
            var codeToCopy = document.getElementById("code-to-copy").innerText;
            navigator.clipboard.writeText(codeToCopy).then(function() {
                alert("代码已复制到剪贴板！");
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>
